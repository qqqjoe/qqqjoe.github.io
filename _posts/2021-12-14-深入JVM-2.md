---
title: 《深入理解Java虚拟机》第二章
description: Java内存区域与内存溢出异常
categories:
- 《深入理解Java虚拟机》读书笔记
tags: 
- 读书笔记
- JVM
---

## 2.1 概述

看起来由虚拟机管理内存一切都很美好。不过，也正是因为Java程序员把控制内存的权力交给了Java虚拟机，**一旦出现内存泄漏和溢出方面的问题**，如果不了解虚拟机是怎样使用内存的，那排查错误、修正问题将会成为一项异常艰难的工作。

## 2.2 运行时数据区域

<img src="https://cdn.jsdelivr.net/gh/qqqjoe/imageRepo@latest/202112141958280.png"/>

### 2.2.1 程序计数器

**程序计数器**(Program Counter Register)是一块较小的内存空间，它可以看作是当前线程所执行的
字节码的行号指示器

每条线程都需要有一个独立的程序计数器，各条线程 之间计数器互不影响，独立存储，我们称这类内存区域为**“线程私有”**的内存。

如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址;如果正在执行的是本地(Native)方法，这个计数器值则应为空(Undefined)。

### 2.2.2 Java虚拟机栈

虚拟机栈描述的是Java方法执行的线程内存模型:每个方法被执行的时候，Java虚拟机都 会同步创建一个**栈帧(Stack Frame)**用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。

经常有人把Java内存区域笼统地划分为堆内存(Heap)和栈内存(Stack)，“栈”通常就是指这里讲的虚拟机栈，或者更多的情况下只是指**虚拟机栈中局部变量表**部分。

局部变量表存放：
* 基本数据类型
* 对象引用
* returnAddress类型(指向了一条字节码指令的地址)

这些数据类型在局部变量表中的存储空间以**局部变量槽(Slot)**来表示

在《Java虚拟机规范》中，对这个内存区域规定了两类异常状况:
* StackOverflowError异常：线程请求的栈深度大于虚 拟机所允许的深度
* OutOfMemoryError异常：如果Java虚拟机栈容量可以动态扩展，当栈扩展时无法申请到足够的内存时，但是HotSpot虚拟机的栈容量是不可以动态扩展的，以前的Classic虚拟机倒是可以。

### 2.2.3 本地方法栈

本地方法栈则是为虚拟机使用到的本地(Native)方法服务，其与虚拟机栈的作用非常相似。

与虚拟机栈一样，本地方法栈也会在栈深度溢出或者栈扩展失 败时分别抛出**StackOverflowError和OutOfMemoryError**异常。

### 2.2.4 Java堆

Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的**唯一目的**就是存放对象实例。

Java堆是垃圾收集器管理的内存区域，因此也可以称为**GC堆**

现在垃圾收集其大部分都是基于**分代收集理论设计**

> 【注意】分代收集理论中的新生代、老年代等这些区域划分仅仅是一部分垃圾收集器的共同特性或者说设计风格而已，而非某个Java虚拟机具体实现的固有内存布局，更不是《Java虚拟机规范》里对Java堆的进一步细致划分。

> 【补充】从分配内存的角度看，所有线程共享的Java堆中可以划分出多个线程私有的**分配缓冲区** (Thread Local Allocation Buffer，TLAB)，以提升对象分配时的效率。

在《Java虚拟机规范》中，Java堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的，这点就像我们用磁盘空间去存储文件一样，并不要求每个文件都连续存放。但对于**大对象(典型的如数组对象)**，多数虚拟机实现出于实现简单、存储高效的考虑，很可能会要求连续的内存空间。

Java堆既可以被实现成固定大小的，也可以是可扩展的，不过当前主流的Java虚拟机都是按照可扩 展来实现的(通过参数**-Xmx和-Xms**设定)。

### 2.2.5 方法区

方法区，也被称为“非堆”，用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据

* 永久代
    * 永久代和方法区并不等价，准确的来说是用永久代来实现方法区而已这样使得HotSpot的垃圾收集器能够像管理Java堆一样管理这部分内存
    * 但是现在看来，当年使用永久代来实现方法区的决定并不是一个好主意，这种设计导致了Java应用更容易遇到 内存溢出的问题
* 永久代的改进：
    * JDK 7的HotSpot，把原本放在永久代的字符串常量池、静态变量等移入到堆内存中
    * JDK 8，完全废弃了永久代的概念，改用与JRockit、J9一样在本地内存中实现的元空间(Meta- space)来代替，把JDK 7中永久代还剩余的内容(主要是类型信息)全部移到元空间中。下面是内存模型图：
   
    <img src="https://cdn.jsdelivr.net/gh/qqqjoe/imageRepo@latest/202112151322471.png"/>

> 《Java虚拟机规范》对**方法区的约束是非常宽松的**，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，甚至还可以选择不实现垃圾收集。

> 这区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说**这个区域的回收效果比较难令人满意**，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收有时又确实是必要的

### 2.2.6 运行时常量池

* 运行时常量池(Runtime Constant Pool)
    * 是方法区的一部分
    * Java虚拟机规范对运行时常量池么有任何细节的要求
    * 具备动态性，运行期间也可以将新的常量放入池中，比如String类的intern()方法
    * 当常量池无法再申请到内存 时会抛出**OutOfMemoryError**异常

* 常量池表/常量池
    * 是Class文件中的一部分，用于存放编译期生 成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。
    * Java虚拟机规范对Class文件的每一部分(自然也包括常量池)的格式都有严格规定

### 2.2.7 直接内存

* 直接内存(Direct Memory)并不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中 定义的内存区域。

* NIO类可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作

* 直接内存不会收到Java堆大小的限制，但是还是会收到本机总内存大小和寻址空间的限制，因此动态扩展时会出现**OutOfMemoryError**异常

## 2.3 HotSpot虚拟机对象探秘

主要介绍**HotSpot虚拟机在Java堆中对象分配、布局和访问的全过程**

### 2.3.1 对象的创建

1. 当Java虚拟机遇到一条字节码`new`指令时
    * 首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的**类加载过程**

2. 在类加载检查通过后，接下来虚拟机将**为新生对象分配内存**
    * 分配内存的方式：指针碰撞、空闲列表
    * 选择哪种分配方式由**Java堆是否规整**决定，而Java堆是否规整又由所采用的**垃圾收集器是否带有空间压缩整理(Compact)的能力**决定。
    * 分配内存存在并发安全问题，解决方案有两种：
        1. **对分配内存空间的动作进行同步处理**——实际上虚拟机是采用CAS配上失败重试的方式保证更新操作的原子性;
        2. 使用**本地线程分配缓冲TLAB**，把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存

3. 虚拟机必须将分配到的内存空间(但不包括对象头)都**初始化为零值**

4. 虚拟机对**对象头**进行必要的设置
    * 例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、是否启用偏向锁等

5. 执行**构造函数**
    * new指令之后会接着执行`<init>()`方法，按照程序员的意愿对对象进行初始化，这样一个真正可用的对象才算完全被构造出来。

### 2.3.2 对象的内存布局

* 在HotSpot虚拟机里，对象在堆内存中的存储布局可以划分为**三个部分：对象头(Header)、实例数据(Instance Data)和对齐填充(Padding)**

1. **对象头**包括两类信息
    1. **Mark Word**：用于存储对象自身的运行时数据，如哈希码(HashCode)、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等
    2. **类型指针**：即对象指向它的类型元数据的指针，Java虚拟机通过这个指针来确定该对象是哪个类的实例。
   
    > 如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据

2. **实例数据**是对象真正存储的有效信息
    1. 保存我们在程序代码里面所定义的各种类型的字段内容，无论是从父类继承下来的，还是在子类中定义的字段都必须记录起来
    2. **存储顺序**会受到虚拟机分配策略参数(-XX:FieldsAllocationStyle参数)和字段在Java源码中定义顺序的影响
    3. 默认的分配策略是，**相同宽度的字段**总是被分配到一起存放，在满足这个前提条件的情况下，**在父类中定义的变量会出现在子类之前**。

3. 对齐填充仅仅起到占位符的作用
    * HotSpot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说就是**任何对象的大小都必须是8字节的整数倍**。

### 2.3.3 对象的访问定位

Java程序会通过**栈上的reference数据**来操作堆上的具体对象，主流的访问方式主要有**使用句柄和直接指针两种**:

1. 使用句柄-稳定句柄地址

Java堆中将可能会划分出一块内存来作为句柄池，reference中存储的就 是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息。

<img src="https://cdn.jsdelivr.net/gh/qqqjoe/imageRepo@latest/202112151533208.png" alt="句柄访问对象"/>

2. 直接指针-访问速度快，HotSpot使用方式

<img src="https://cdn.jsdelivr.net/gh/qqqjoe/imageRepo@latest/202112151538450.png"/>