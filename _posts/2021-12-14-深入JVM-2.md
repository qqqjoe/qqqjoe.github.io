---
title: 《深入理解Java虚拟机》第二章
description: Java内存区域与内存溢出异常
categories:
- 《深入理解Java虚拟机》读书笔记
tags: 
- 读书笔记
- JVM
---

## 2.1 概述

看起来由虚拟机管理内存一切都很美好。不过，也正是因为Java程序员把控制内存的权力交给了Java虚拟机，**一旦出现内存泄漏和溢出方面的问题**，如果不了解虚拟机是怎样使用内存的，那排查错误、修正问题将会成为一项异常艰难的工作。

## 2.2 运行时数据区域

<img src="https://cdn.jsdelivr.net/gh/qqqjoe/imageRepo@latest/202112141958280.png"/>

### 2.2.1 程序计数器

**程序计数器**(Program Counter Register)是一块较小的内存空间，它可以看作是当前线程所执行的
字节码的行号指示器

每条线程都需要有一个独立的程序计数器，各条线程 之间计数器互不影响，独立存储，我们称这类内存区域为**“线程私有”**的内存。

如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址;如果正在执行的是本地(Native)方法，这个计数器值则应为空(Undefined)。

### 2.2.2 Java虚拟机栈

虚拟机栈描述的是Java方法执行的线程内存模型:每个方法被执行的时候，Java虚拟机都 会同步创建一个**栈帧(Stack Frame)**用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。

经常有人把Java内存区域笼统地划分为堆内存(Heap)和栈内存(Stack)，“栈”通常就是指这里讲的虚拟机栈，或者更多的情况下只是指**虚拟机栈中局部变量表**部分。

局部变量表存放：
* 基本数据类型
* 对象引用
* returnAddress类型(指向了一条字节码指令的地址)

这些数据类型在局部变量表中的存储空间以**局部变量槽(Slot)**来表示

在《Java虚拟机规范》中，对这个内存区域规定了两类异常状况:
* StackOverflowError异常：线程请求的栈深度大于虚 拟机所允许的深度
* OutOfMemoryError异常：如果Java虚拟机栈容量可以动态扩展，当栈扩展时无法申请到足够的内存时，但是HotSpot虚拟机的栈容量是不可以动态扩展的，以前的Classic虚拟机倒是可以。

### 2.2.3 本地方法栈

本地方法栈则是为虚拟机使用到的本地(Native)方法服务，其与虚拟机栈的作用非常相似。

与虚拟机栈一样，本地方法栈也会在栈深度溢出或者栈扩展失 败时分别抛出**StackOverflowError和OutOfMemoryError**异常。

### 2.2.4 Java堆

Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的**唯一目的**就是存放对象实例。

Java堆是垃圾收集器管理的内存区域，因此也可以称为**GC堆**

现在垃圾收集其大部分都是基于**分代收集理论设计**

> 【注意】分代收集理论中的新生代、老年代等这些区域划分仅仅是一部分垃圾收集器的共同特性或者说设计风格而已，而非某个Java虚拟机具体实现的固有内存布局，更不是《Java虚拟机规范》里对Java堆的进一步细致划分。

> 【补充】从分配内存的角度看，所有线程共享的Java堆中可以划分出多个线程私有的**分配缓冲区** (Thread Local Allocation Buffer，TLAB)，以提升对象分配时的效率。

在《Java虚拟机规范》中，Java堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的，这点就像我们用磁盘空间去存储文件一样，并不要求每个文件都连续存放。但对于**大对象(典型的如数组对象)**，多数虚拟机实现出于实现简单、存储高效的考虑，很可能会要求连续的内存空间。

Java堆既可以被实现成固定大小的，也可以是可扩展的，不过当前主流的Java虚拟机都是按照可扩 展来实现的(通过参数**-Xmx和-Xms**设定)。

### 2.2.5 方法区

方法区，也被称为“非堆”，用于存储已被虚拟机加载 的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据